# アーキテクチャ設計書

## 1. 全体アーキテクチャ概要

### 1.1 システム構成
```
┌─────────────────────────────────────────────────────────┐
│                    Frontend (Next.js)                    │
│  - App Router / Pages Router                            │
│  - Tailwind CSS                                          │
│  - Server Components / Client Components                │
└──────────────────┬──────────────────────────────────────┘
                   │ REST API / GraphQL
┌──────────────────▼──────────────────────────────────────┐
│              Backend (Nest.js)                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │ Reports  │  │Attendance│  │  Ideas   │              │
│  │  Module  │  │  Module  │  │  Module  │  ...          │
│  └──────────┘  └──────────┘  └──────────┘              │
│                                                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │   Auth   │  │ Schedule │  │  Queue   │              │
│  │  Module  │  │  Module  │  │  Worker  │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└──────┬──────────────┬──────────────┬────────────────────┘
       │              │              │
┌──────▼──────┐ ┌────▼─────┐ ┌─────▼──────┐
│   MySQL     │ │ MongoDB  │ │   Redis    │
│ (構造化DB)  │ │(ドキュメント)│ │  (Queue)   │
└─────────────┘ └──────────┘ └────────────┘
       │
┌──────▼──────────────────────────────────────┐
│      External Services                      │
│  - Outlook Graph API                        │
│  - Azure AD (認証)                          │
└─────────────────────────────────────────────┘
```

### 1.2 技術スタック
- **フロントエンド**: Next.js 14+ (App Router), TypeScript, Tailwind CSS
- **バックエンド**: Nest.js, TypeScript
- **データベース**: MySQL 8.0, MongoDB 6.0
- **キャッシュ/キュー**: Redis
- **認証**: Azure AD (OpenID Connect)
- **コンテナ**: Docker, Docker Compose
- **CI/CD**: GitHub Actions (予定)

## 2. モノレポ構成の採用

### 2.1 採用理由
- **コード共有の容易性**: フロントエンドとバックエンドで型定義やバリデーションロジックを共有可能
- **一括管理の利便性**: 依存関係の更新、リリース管理、CI/CD パイプラインを一元化
- **開発効率**: クロスレイヤーでの変更を同一コミットで完結でき、レビューも効率的
- **小規模チーム向き**: 現時点では少数メンバーでの開発を想定しており、モノレポの複雑さが許容範囲

### 2.2 ディレクトリ構造
```
attendance-management-app/
├── apps/
│   ├── frontend/          # Next.js アプリケーション
│   └── backend/           # Nest.js アプリケーション
├── docs/                   # ドキュメント
│   ├── requirements/      # 要件定義
│   └── design/            # 設計資料
└── infrastructure/         # インフラ設定
    ├── docker/            # Docker Compose
    ├── mysql/             # MySQL 初期化スクリプト
    └── mongodb/           # MongoDB 初期化スクリプト
```

### 2.3 将来の拡張性
- 共通ライブラリ（`packages/`）の追加を想定
- マイクロサービス化する場合は、サービス単位でリポジトリ分割を検討

## 3. フロントエンド設計思想

### 3.1 Next.js App Router の採用
- **Server Components を優先**: 初期レンダリングをサーバー側で実行し、パフォーマンスとSEOを最適化
- **Client Components は必要最小限**: インタラクティブな要素（フォーム、モーダル）のみクライアントコンポーネント化
- **API Routes は軽量処理のみ**: 認証状態チェック、プロキシ処理程度に留め、重い処理はバックエンドに委譲

### 3.2 状態管理
- **Server State**: React Query (TanStack Query) で API データをキャッシュ・同期
- **Client State**: Zustand または Context API で UI 状態（モーダル開閉、フォーム入力途中）を管理
- **グローバル状態は最小化**: 認証情報は Server Component から取得し、必要に応じて Client Component に渡す

### 3.3 UI/UX 設計
- **Tailwind CSS による一貫性**: デザインシステム（カラーパレット、スペーシング）を Tailwind 設定で統一
- **レスポンシブデザイン**: モバイルファーストで設計
- **アクセシビリティ**: ARIA 属性、キーボード操作、スクリーンリーダー対応を意識

### 3.4 パフォーマンス最適化
- **静的生成 (SSG)**: 日報テンプレート一覧など、更新頻度の低いページは静的生成
- **インクリメンタル静的再生成 (ISR)**: 日報一覧など、定期的に更新されるページは ISR を適用
- **画像最適化**: Next.js Image コンポーネントで自動最適化
- **コード分割**: 動的インポートでバンドルサイズを削減

## 4. バックエンド設計思想

### 4.1 ドメイン中心のモジュラ構成
各業務ドメインを独立した Nest.js モジュールとして実装：

- **Reports Module**: 日報作成、検索、コメント
- **Attendance Module**: 勤務表入力、集計、承認
- **Leave Module**: 休日申請、承認フロー
- **Ideas Module**: アイデア投稿、評価、共有
- **Schedule Module**: スケジュール集約、Outlook 連携
- **Auth Module**: 認証・認可、ユーザー管理

各モジュールは以下のレイヤーで構成：
```
Module
├── Controller (API エンドポイント、DTO バリデーション)
├── Service (ビジネスロジック)
├── Repository (データアクセス)
└── Entity/Document (データモデル)
```

### 4.2 レイヤードアーキテクチャ + CQRS のハイブリッド

#### 基本パターン（レイヤード）
```
Controller → Service → Repository → Database
```
- シンプルな CRUD 操作はこのパターンで実装
- 各レイヤーの責務を明確に分離

#### CQRS パターン（読み取り最適化）
- **Query Service**: 勤務表集計、日報検索など、複雑な読み取り処理を専用サービスで実装
- **Command Service**: 作成・更新・削除は通常の Service で実装
- 必要に応じて `@nestjs/cqrs` を活用し、ドメインイベントでモジュール間連携

### 4.3 DTO/Validation/Transformer の徹底
- **入力 DTO**: `class-validator` でバリデーション、`class-transformer` で型変換
- **出力 DTO**: ユースケース単位で定義し、不要な情報を除外
- **Swagger/OpenAPI**: `@nestjs/swagger` で自動生成し、フロントエンド開発と連携

### 4.4 外部連携の抽象化
- **Adapter パターン**: Outlook Graph API などの外部サービスは Adapter クラスでラップ
- **Facade パターン**: 複数の外部 API を組み合わせる場合は Facade で統一インターフェースを提供
- **依存性逆転**: アプリケーション層はインターフェースに依存し、実装詳細に依存しない

### 4.5 エラーハンドリング
- **例外フィルター**: グローバル例外フィルターで統一的なエラーレスポンスを返却
- **カスタム例外**: ビジネスロジックエラーは独自例外クラスで定義
- **ログ記録**: エラー発生時は構造化ログ（JSON）で記録

## 5. データベース設計思想

### 5.1 データベース選択基準

#### MySQL（構造化データ）
- **用途**: 勤怠データ、日報メタ情報、ユーザー情報、承認フロー
- **理由**: トランザクション整合性が重要、リレーショナルな関係性が明確
- **ORM**: TypeORM または Prisma を採用

#### MongoDB（ドキュメントデータ）
- **用途**: ネタ帳、アイデア、リッチコンテンツ（添付ファイルメタ、コメント）
- **理由**: スキーマの柔軟性、階層構造データの扱いやすさ
- **ODM**: Mongoose を採用

### 5.2 データ整合性の考え方
- **強整合性が必要なデータ**: 勤怠データ、承認フロー → MySQL でトランザクション管理
- **最終的整合性で許容**: ネタ帳、アイデア → MongoDB で管理、必要に応じて非同期で MySQL に集約
- **ドメインイベント**: モジュール間のデータ同期はイベント駆動で実現

### 5.3 マイグレーション管理
- **TypeORM Migrations**: MySQL スキーマ変更はマイグレーションファイルで管理
- **MongoDB**: スキーマ変更はアプリケーションレベルでバージョニング（必要に応じてスクリプト化）
- **CI/CD 統合**: マイグレーションは自動実行し、ロールバック手順も整備

## 6. 認証・認可設計

### 6.1 認証フロー
1. **Azure AD 連携**: OpenID Connect で SSO 認証
2. **JWT 発行**: 認証成功後、Nest.js 側で JWT を発行（リフレッシュトークンも併用）
3. **セッション管理**: Redis にセッション情報をキャッシュ（オプション）

### 6.2 認可（RBAC）
- **ロール定義**: 
  - `admin`（管理者）: システム全体の管理権限
  - `team_manager`（チーム管理者）: チームメンバーの管理、提出状況確認、承認権限
  - `employee`（社員・チームメンバー）: 日報作成、勤務表入力、休日登録など基本機能
  - `partner`（パートナー・チームメンバー）: 社員と同等の基本機能を利用可能
- **Guard 実装**: `@Roles()` デコレータと Guard でエンドポイント単位に権限チェック
- **リソースベース認可**: 自分の日報のみ編集可能など、リソース所有者チェックも実装

### 6.3 セキュリティ対策
- **パスワードポリシー**: Azure AD 側で管理（アプリ側では直接扱わない）
- **CSRF 対策**: SameSite Cookie、CSRF トークン検証
- **Rate Limiting**: `@nestjs/throttler` で API 呼び出し制限

## 7. 外部連携設計（Outlook）

### 7.1 Outlook Graph API 連携
- **認証**: Azure AD アプリ登録で Graph API 権限を取得
- **同期方式**: 
  - **初回同期**: バックエンド起動時またはユーザー初回ログイン時に全件取得
  - **増分同期**: Webhook または定期的なポーリングで変更を検知
- **データキャッシュ**: MySQL にスケジュール情報をキャッシュし、Graph API 呼び出しを最小化

### 7.2 エラーハンドリング
- **リトライロジック**: 一時的な API エラーは指数バックオフでリトライ
- **フォールバック**: Graph API が利用不可の場合、キャッシュデータを返却

## 8. 非同期処理設計

### 8.1 AWS EventBridge + Lambda（サーバーレス処理）
- **用途**: 
  - 勤務表の自動出力（月次、休日登録完了時）
  - 日報未提出催促通知（18:00と翌日9:30の定期実行）
  - スケジュールベースの定期処理
- **実装方針**:
  - EventBridge でスケジュールイベント（月次トリガー、日次トリガー）やカスタムイベント（休日登録完了）を発行
  - Lambda 関数で勤務表の集計・Excel 生成・S3/SharePoint アップロードを実行
  - Lambda 関数で日報未提出検知・通知送信を実行（通知設定を参照し、OFFの場合は送信をスキップ）
  - Nest.js から EventBridge にイベントを送信（AWS SDK 利用）
- **開発・管理方針**:
  - Lambda 関数は別プロジェクト（リポジトリ）で管理し、独立して開発・デプロイ
  - メインアプリケーションとは API 経由で連携

### 8.2 キューシステム（BullMQ + Redis）
- **用途**: 
  - 通知送信（メール、Slack）
  - Outlook 同期処理
  - レポート生成・エクスポート
- **Worker プロセス**: Nest.js の別プロセスとして実装、Docker コンテナで分離可能
- **通知設定の考慮**:
  - 通知送信前にユーザーの通知設定を確認
  - 通知設定がOFFの場合は送信をスキップ
  - 通知種別ごと（日報催促、勤務表入力未完了通知など）にON/OFFを設定可能

### 8.3 イベント駆動アーキテクチャ
- **ドメインイベント**: 日報提出、承認完了、休日登録完了などの重要なビジネスイベントを発行
- **イベントハンドラ**: 
  - アプリケーション内: 各モジュールでイベントを購読し、必要な処理を実行
  - 外部（AWS）: EventBridge にイベントを送信し、Lambda で処理
- **例**: 
  - 日報提出イベント → 通知送信、統計更新
  - 休日登録完了イベント → EventBridge に送信 → Lambda で勤務表自動出力
  - 日次トリガー（EventBridge スケジュール、18:00と翌日9:30） → Lambda で日報未提出検知・催促通知送信
  - 月次トリガー（EventBridge スケジュール） → Lambda で勤務表自動出力、未完了メンバーに通知

## 9. セキュリティ設計

### 9.1 データ保護
- **暗号化**: 機密情報（個人情報、勤怠データ）は保存時暗号化を検討
- **監査ログ**: 全操作（作成、更新、削除、承認）を監査ログテーブルに記録
- **データ保持**: 退職者のデータは一定期間後にアーカイブまたは削除

### 9.2 API セキュリティ
- **HTTPS 必須**: 本番環境では HTTPS のみ許可
- **CORS 設定**: 許可されたオリジンのみアクセス可能
- **入力サニタイズ**: SQL インジェクション、XSS 対策を徹底

### 9.3 インフラセキュリティ
- **シークレット管理**: 環境変数、API キーは Secrets Manager で管理
- **ネットワーク分離**: 本番環境では VPC 内で通信を制限
- **脆弱性スキャン**: CI/CD パイプラインで依存パッケージの脆弱性をチェック

## 10. 開発・運用方針

### 10.1 インフラ管理（IaC）
- **Infrastructure as Code**: すべての AWS リソースを IaC で管理
  - **ツール**: Terraform または AWS CDK を採用
  - **対象リソース**: CloudFront、S3、EventBridge、Lambda、IAM ロール、VPC など
- **構成管理**:
  - インフラ定義ファイルをバージョン管理（Git）
  - 環境ごと（開発/ステージング/本番）に設定を分離
  - 変更は Pull Request 経由でレビュー・承認
- **デプロイ**:
  - CI/CD パイプラインで IaC の適用を自動化
  - 変更前のプレビュー（plan/diff）を実行
- **Lambda プロジェクト**:
  - Lambda 関数は別リポジトリで管理
  - 独自の CI/CD パイプラインでデプロイ
  - メインアプリケーションとは独立してバージョン管理

### 10.2 コード品質
- **Linting**: ESLint、Prettier でコード規約を統一
- **型安全性**: TypeScript の strict モードを有効化
- **テスト**: 
  - ユニットテスト（Jest）: Service、Repository 層を中心に実装
  - E2E テスト（Supertest）: API エンドポイントの統合テスト

### 10.3 CI/CD
- **GitHub Actions**: 
  - プルリクエスト時に Lint、テスト、ビルドを実行
  - マージ後は単一ワークフローでフロントエンドとバックエンドを順次デプロイ
    - **ステップ1: バックエンドデプロイ**
      - Docker イメージをビルドし、ECR にプッシュ
      - ECS/Fargate にデプロイ（必要に応じて）
    - **ステップ2: フロントエンドデプロイ**
      - Next.js をビルドし、S3 にアップロード
      - CloudFront のキャッシュを無効化
    - **ステップ3: デプロイ完了通知**
      - 全体のデプロイステータスを通知
  - 本番デプロイは手動承認を経て実行（オプション）
- **デプロイ先**: 
  - フロントエンド: AWS CloudFront + S3
  - バックエンド: ECS/Fargate（または EC2）
- **デプロイ方針**: 同一ワークフロー内で実行することで、バージョンの一貫性とデプロイの可視性を確保

### 10.4 監視・ログ
- **アプリケーションログ**: 構造化ログ（JSON）で出力、ログ集約サービスに送信
- **メトリクス**: API レスポンスタイム、エラー率、キュー処理状況を監視
- **アラート**: エラー率の急増、可用性低下時に通知

### 10.5 ドキュメント
- **API ドキュメント**: Swagger/OpenAPI で自動生成、開発者向けに公開
- **アーキテクチャ図**: システム構成、データフローを図示
- **運用マニュアル**: デプロイ手順、障害対応手順を整備

## 11. 将来の拡張性

### 11.1 スケーラビリティ
- **水平スケール**: ステートレスな設計により、複数インスタンスでの運用が可能
- **データベース分割**: 必要に応じて読み取り専用レプリカを追加

### 11.2 機能拡張
- **マイクロサービス化**: モジュール単位で独立したサービスに分割可能な設計
- **外部連携拡張**: Google Calendar、Slack などの連携を Adapter パターンで追加可能

---

※ 本ドキュメントは設計思想の初期版です。実装を進めながら随時更新してください。

